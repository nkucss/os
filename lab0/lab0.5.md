<h1><center>lab0.5实验报告</center></h1>

## 一、实验目的

实验0.5主要讲解最小可执行内核和启动流程。我们的内核主要在 Qemu 模拟器上运行，它可以模拟一台 64 位 RISC-V 计算机。为了让我们的内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识。

## 二、实验过程

### 练习1:启动GDB验证启动流程

#### 1.为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程。

在使用 `make gdb` 前，先执行 `make debug` ，该步骤是为了编译生成包含调试信息的可执行文件。具体来说，`make debug` 通常会根据 Makefile 里的设定，使用适合调试的编译选项，生成带有符号信息的二进制文件。

进入gbd，使用`x/10i $pc `指令查看0x1000处的10条汇编指令：

```assembly
0x1000:      auipc   t0,0x0     
0x1004:      addi    a1,t0,32   
0x1008:      csrr    a0,mhartid 
0x100c:      ld      t0,24(t0)  
0x1010:      jr      t0		    
0x1014:      unimp
0x1016:      unimp
0x1018:      unimp
0x101a:      0x8000
0x101c:      unimp
```

- `auipc t0, 0x0`: 将当前程序计数器（PC）的值加载到寄存器 t0 中。

- `addi a1, t0, 32`: 将寄存器 t0 的值加上 32，并将结果存储在寄存器 a1 中。

- `csrr a0, mhartid`: 读取硬件线程 ID（hart ID），并将其存储在寄存器 a0 中。

- `ld t0, 24(t0)`: 从寄存器 t0 中存储的地址偏移 24 字节的位置加载 64 位的数据，并存储到寄存器 t0 中。

- `jr t0`: 跳转到寄存器 t0 中存储的地址。

- `unimp`: 表示未实现的指令。这些通常是占位符，表示程序不应执行到这些位置。

初始化完成后，处理器会加载应用程序二进制文件到内存中，这些指令会实现跳转到应用程序的入口点t0（0x80000000）。
使用`si`单步调试

```assembly
(gdb) si
0x0000000000001004 in ?? ()
(gdb) si
0x0000000000001008 in ?? ()
(gdb) si
0x000000000000100c in ?? ()
(gdb) si
0x0000000000001010 in ?? ()
(gdb) si
0x0000000080000000 in ?? ()
```

作为 bootloader 的 OpenSBI.bin 被加载到物理地址为 0x80000000 的内存区域。因此，当执行 jr t0 指令后，QEMU 模拟的 RISC-V 处理器将开始执行 OpenSBI.bin 程序。

使用`x/10i $pc `指令查看0x80000000处的10条汇编指令，该地址处加载的是作为bootloader的OpenSBI.bin，该处的作用为加载操作系统内核并启动操作系统的执行。
```assembly
0x80000000: csrr a6,mhartid
0x80000004: bgtz a6,0x80000108
0x80000008: auipc t0,0x0
0x8000000c: addi t0,t0,1032
0x80000010: auipc t1,0x0
0x80000014: addi t1,t1,-16
0x80000018: sd t1,0(t0)
0x8000001c: auipc t0,0x0
0x80000020: addi t0,t0,1020
0x80000024: ld t0,0(t0)
```

- `csrr a6, mhartid`: 从 mhartid CSR中读取硬件线程 ID（hart ID），并将其存储在寄存器 a6 中

- `bgtz a6, 0x80000108`: 如果寄存器 a6 的值大于 0，则跳转到地址 0x80000108。

- `auipc t0, 0x0`: 将一个立即数（0x0）加到当前的程序计数器（PC）的高 20 位，然后将结果存储到目标寄存器 t0 中。

- `addi t0, t0, 1032`: 将寄存器 t0 中的值加上 1032，并将结果存储在 t0 中。

- `auipc t1, 0x0`: 将一个立即数（0x0）加到当前的程序计数器（PC）的高 20 位，然后将结果存储到目标寄存器 t1 中。

- `addi t1, t1, -16`: 将寄存器 t1 中的值减去 16，并将结果存储在 t1 中。

- `sd t1, 0(t0)`: 将寄存器 t1 中的值存储到 t0 地址指定的内存位置。

- `addi t0, t0, 1020`: 将寄存器 t0 中的值加上 1020，并将结果存储在 t0 中。

- `ld t0, 0(t0)`:  从 t0 寄存器中存储的地址位置加载一个双字（64 位）到寄存器 t0 中。

接着输入指令`break *0x80200000`，在目标函数kern_entry的第一条指令处设置断点，输出如下：

```assembly
Breakpoint 1 at 0x80200000: file kern/init/entry.S, line 7.
```
输入`continue`执行直到断点。
输入指令`x/5i 0x80200000`：
```assembly
0x80200000 <kern_entry>:      auipc   sp,0x3         
0x80200004 <kern_entry+4>:    mv      sp,sp           
0x80200008 <kern_entry+8>:    j       0x8020000c <kern_init> 
0x8020000c <kern_init>:       auipc   a0,0x3          
0x80200010 <kern_init+4>:     addi    a0,a0,-4        
```

- `auipc sp,0x3`: 将一个立即数（0x3）加到当前的程序计数器（PC）的高 20 位，然后将结果存储到目标寄存器 sp 中。

- `mv sp,sp`: 占位或对齐指令，保持 sp 寄存器不变，无实际操作效果。

- `j 0x8020000c <kern_init>`: 无条件跳转到 kern_init 标签处，进入内核初始化过程。

- `auipc a0,0x3`: 将一个立即数（0x3）加到当前的程序计数器（PC）的高 20 位，然后将结果存储到目标寄存器 a0 中。

- `addi a0,a0,-4`: 将 a0 中的地址值减去 4，进一步调整内存地址，准备进行初始化操作。


kern_entry 中的指令主要是初始化栈指针并跳转到内核初始化函数 kern_init。
kern_init 的指令主要用于设置寄存器 a0 的值，并对其进行调整，准备进行下一步的内存或数据结构操作。

#### 2.说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？

当 RISC-V 硬件加电启动时，处理器首先执行位于物理地址 0x1000 到 0x1010 之间的指令序列。该指令序列的最后一条指令位于 0x1010，其作用是引导处理器跳转到物理地址 0x80000000，开始执行加载在该地址的 OpenSBI 程序。此过程标志着从初始启动代码到 OpenSBI 的过渡，为后续内核的加载和运行奠定基础。

```assembly
0x1000:      auipc   t0,0x0     
0x1004:      addi    a1,t0,32   
0x1008:      csrr    a0,mhartid 
0x100c:      ld      t0,24(t0)  
0x1010:      jr      t0		    
```
- `auipc t0, 0x0`: 将当前程序计数器（PC）的值加载到寄存器 t0 中。

- `addi a1, t0, 32`: 将寄存器 t0 的值加上 32，并将结果存储在寄存器 a1 中。

- `csrr a0, mhartid`: 读取硬件线程 ID（hart ID），并将其存储在寄存器 a0 中。

- `ld t0, 24(t0)`: 从寄存器 t0 中存储的地址偏移 24 字节的位置加载 64 位的数据，并存储到寄存器 t0 中。

- `jr t0`: 跳转到寄存器 t0 中存储的地址。

通过 auipc 和 addi 指令计算一个偏移地址，并将其存入 a1，作为参数传递。读取当前硬件线程（hart）的 ID，存入 a0，从特定的内存地址（0x1018）加载一个目标地址（0x80000000），并跳转到该地址执行（通过 jr t0）。