<h1><center>lab2实验报告</center></h1>

## 练习一

+ 在操作系统中，物理内存通过地址映射机制转化为虚拟内存，主要依靠硬件和操作系统的协作来实现。

+ 虚拟地址是进程在访问内存时看到的地址，而物理地址是实际内存的地址。每个进程有独立的虚拟地址空间，使得不同进程可以使用相同的虚拟地址而不会冲突。操作系统会为每个进程维护一个页表，页表将虚拟地址映射到物理地址。虚拟内存通常被划分为固定大小的页面（如4KB），而物理内存则对应页框（Page Frame）。页表记录每个虚拟页面到物理页框的映射关系。

+ 可以把它比作在大楼里安排房间：虚拟内存就像是一个理想的大楼，每层楼每间房间都编号整齐，但其实楼里真实的房间（物理内存）是分散的，不一定按理想顺序排列。为了让大家觉得房间是连贯的，我们用一个“地址表”（页表）来记录理想顺序（虚拟内存）和真实位置（物理内存）之间的对应关系。

**物理内存分配与回收的过程：**

从空闲内存块的链表上查找第一个大小大于所需内存的块，分配出去，回收时会按照地址从小到大的顺序插入链表，并且合并与之相邻且连续的空闲内存块。

**First Fit算法的主要思想：**

维护一个空闲块列表，当有内存请求时，从列表中找到第一个足够大的块来满足请求。

**各个函数的作用：**

###### 结构体定义

+ `free_area_t free_area`: 用于管理自由内存区域的结构体，包括自由页面的链表和自由页面的计数。
+ `free_list`和`nr_free`: 宏定义，便于访问自由链表和自由页面的数量。
  
###### 函数定义

+ `default_init`：初始化空闲内存块的链表，将空闲块的个数设置为0。
  + 初始化了空闲块列表 `free_list` 以及空闲页面数量 `nr_free`。

+ `default_init_memmap`：用于初始化一个空闲内存块。先查询空闲内存块的链表，按照地址顺序插入到合适的位置，并将空闲内存块个数加n。
  + 首先初始化了每个页面的属性，包括标志位 `flags` 和 `property`，并将页面引用计数设置为0。
  + 然后，它将首个页面的 `property` 设置为块的总数，表示此块中的页面数量。
  + 最后，它将这些页面添加到 `free_list` 中，并更新 `nr_free` 计数。

+ `default_alloc_pages`：用于分配给定大小的内存块。如果剩余空闲内存块大小多于所需的内存区块大小，则从链表中查找大小超过所需大小的页，并更新该页剩余的大小。
  + 遍历空闲块列表，查找第一个满足请求的块（块大小大于等于 `n`）。
  + 如果找到了合适的块，会将块分割成两部分，一部分用于分配，另一部分保留在列表中。
  + 如果分割后剩余的块大小大于 `n`，则更新剩余块的 `property` 并将其添加到列表中。
  + 最后，它减少 `nr_free` 计数，并标记已分配的页面。

+ `default_free_pages`：用于释放内存块。将释放的内存块按照顺序插入到空闲内存块的链表中，并合并与之相邻且连续的空闲内存块。
  + 首先将页面的属性重置，并将页面引用计数设置为0。
  + 然后，将页面添加到空闲块列表中，同时尝试合并相邻的空闲块。
  + 如果释放的页面与前一个页面或后一个页面相邻，会尝试将它们合并为一个更大的空闲块。
  + 最后，更新 `nr_free` 计数。


**改进空间：**

* 适当缓存上次的分配位置：

First-fit算法通常从头开始查找合适的空闲块。如果我们保存上一次分配的内存位置，下一次分配时可以从上次位置继续搜索，减少查找时间。

*块合并优化：

实现内存回收时，可以考虑对相邻的空闲内存块进行合并，避免碎片化的产生。这会在后续的内存分配中提供较大且连续的空间。

* 优化空闲链表管理：

使用分段的空闲链表，将空闲的内存块按大小分类。例如，将大小分为多个段（如4KB以下、4KB到16KB等）。分配时直接选择合适大小的链表段，从而缩短搜索时间。

*小块预留：

考虑保留一定数量的小块内存池，用于满足小规模的内存分配请求。这种方式可以减少较大内存块被分配给小请求而导致的碎片问题。

* 最佳块大小提示机制：

在内存分配请求附近，设置一个“最佳块大小提示”。在请求内存分配时，可以通过最佳大小提示选择最优的块大小，进一步提升内存利用率和查找效率。

## 练习二

**设计实现过程**

在 best_fit_pmm.c 文件中实现了 Best-Fit 页面分配算法，旨在减少内存碎片。该算法会遍历所有空闲内存块，选择最小但能够满足请求的块进行分配。相比之下，First-Fit 算法仅寻找第一个符合条件的块。Best-Fit 的优势在于，它会选择与需求最匹配的内存块，避免分配过大的空间，从而减少内存浪费。

* 初始化：初始化空闲块列表，将可用的内存区域添加至管理列表中。
* 分配页面：分配时遍历空闲块列表，寻找最接近需求且足够大的块。找到合适块后，将其分配；若块的大小超出需求，则将剩余部分重新作为新块加入空闲列表。
* 释放页面：释放时将页面标记为空闲，并与相邻空闲块合并，以保持连续的空闲块结构。

**关键函数**

在 `best_fit_pmm.c` 文件中，Best-Fit 页面分配算法的关键函数实现如下:

+ **`best_fit_init`**
   + **Best-Fit 实现**：用于初始化内存管理器，在 Best-Fit 算法中，它创建并初始化管理空闲内存块的数据结构，为后续的页面分配和释放做好准备。通常会初始化一个空闲块列表（例如使用链表或数组），并设置空闲块管理的其他必要参数。
   + **与 First-Fit 的对比**：`default_init` 在 First-Fit 中的主要目标类似，即初始化内存管理器。不同之处在于，First-Fit 初始化的空闲列表并不需要按大小进行排序或分级，而 Best-Fit 初始化时通常会预先为优化查找而准备有序列表结构。

+ **`best_fit_init_memmap`**
   +  **Best-Fit 实现**：此函数初始化内存映射表，标记哪些页面可用、哪些页面已分配。在 Best-Fit 中，`best_fit_init_memmap` 将每个可用的内存区域分割成块，并将它们添加到空闲块列表中。
   + **与 First-Fit 的对比**：在 First-Fit 中，`default_init_memmap` 的作用相同，但该算法并不会专门考虑块大小的问题，因此对块列表的插入顺序也无关紧要。而在 Best-Fit 中，分割后的块通常按照大小进行管理，以方便分配时更高效地找到最佳匹配。

+ **`best_fit_alloc_pages`**
   + **Best-Fit 实现**：用于分配页面，是 Best-Fit 算法的核心实现。
   
   + **核心代码**：
     ```c
     struct page *best_fit_alloc_pages(size_t n) {
         struct page *best_fit = NULL;
         size_t best_size = SIZE_MAX;
         list_for_each_entry(page, &free_list, list) {
             if (page->size >= n && page->size < best_size) {
                 best_size = page->size;
                 best_fit = page;
             }
         }
         if (best_fit) {
             if (best_fit->size > n) {
                 split_page(best_fit, n);
             }
             list_del_init(&best_fit->list);
         }
         return best_fit;
     }
     ```
    + **与 First-Fit 的对比**：在 First-Fit 中，`default_alloc_pages` 会直接遍历空闲列表中的块，找到第一个满足大小要求的块，并立即分配出去。而 Best-Fit 会遍历整个空闲列表以找到最小且满足要求的块，因此其查找过程更为复杂，但选择更精确，有助于减少内存碎片。

+ **`best_fit_free_pages`**
   + **Best-Fit 实现**：用于释放页面，使其重新变为空闲状态。

    **核心代码**：
     ```c
     void best_fit_free_pages(struct page *page) {
         list_add(&page->list, &free_list);
         merge_free_blocks(&free_list);
     }
     ```
   - **与 First-Fit 的对比**：`default_free_pages` 在 First-Fit 和 Best-Fit 中的基本逻辑相同，都会将释放的页面加入到空闲列表，并调用合并函数（如 `merge_free_blocks`）来合并相邻的空闲块。两者都旨在保持空闲块的连续性，但 Best-Fit 的合并对于后续最佳分配有更大意义，因为碎片化对 Best-Fit 的分配效率影响更大。

总之，Best-Fit 和 First-Fit 的主要差异体现在分配逻辑上：Best-Fit 会遍历整个列表，找到最符合要求的最小块，以尽量减少碎片化；而 First-Fit 只需找到第一个满足条件的块，因此速度更快，但容易造成内存碎片。

make qemu 和 make grade 如下：

![make qemu](https://github.com/nkucss/os/blob/main/lab2/make_qemu.png?raw=true "make qemu")
![make grade](https://github.com/nkucss/os/blob/main/lab2/make_grade.png?raw=true "make grade")


**对物理内存的分配和释放**

物理内存的分配和释放由空闲块列表控制：

* 分配内存：

Best-Fit 算法会遍历所有空闲块，选择最小但足够满足需求的块，以避免分配过大的内存空间。找到合适块后，如果块的大小超过所需容量，算法会将多余部分分割出来，并重新加入空闲列表。
相比之下，First-Fit 算法只需找到第一个符合条件的块便立即分配，分配速度更快，但容易产生更多内存碎片。

* 释放内存：

在释放内存时，页面会被标记为空闲，然后加入到空闲块列表中。Best-Fit 和 First-Fit 都会尝试合并相邻的空闲块，以减少碎片并增加大块的空闲空间，便于后续大页面的分配。

**改进空间**

不足之处：Best-Fit 算法在查找最佳块时，需要遍历整个空闲块列表，这使得其时间复杂度较高，特别是在内存碎片较多的情况下会进一步影响效率。

#### 改进方案：

- **使用有序链表**：维护一个按块大小排序的空闲列表，以减少查找时间，无需每次遍历整个列表。
- **使用最小堆**：将空闲块存入最小堆，每次分配时直接获取最小且合适的块，将分配时间复杂度优化至 \(O(\log n)\)。
- **分级空闲列表**：将空闲块按大小分组，这样在分配时仅需检查与需求对应的大小组，减少遍历次数。

这些改进可以有效降低 Best-Fit 算法的查找时间，提高分配速度，特别是在大规模内存管理的场景中表现更为显著。


## 扩展练习Challeng3：可用物理内存获取

1. **利用 BIOS 或 UEFI 提供的内存映射**

在启动操作系统时，可以利用 BIOS 或 UEFI 提供的中断或调用接口来获取物理内存的分布情况。这种方法通过调用系统固件的接口获得系统内存的详细布局信息，既精准又方便，是操作系统获取物理内存映射的标准方式。

**具体实现：**

+ BIOS（使用INT 0x15, AX=0xE820中断）：
  
  在基于 BIOS 的传统系统中，INT 0x15, AX=0xE820中断调用被用于获取内存映射表。这个中断会返回一张包含多个条目的内存表，每个条目描述了内存的一个区域，包括起始地址、大小以及类型（如可用内存、已保留内存等）。

  每个条目中的类型通常有以下几种：
  1: 可用的物理内存区域，可以被操作系统分配和使用。
  2: 已保留的内存，不可用于分配，一般保留给系统或硬件。
  3: 可回收的 ACPI 内存区域，可用于重启后重新分配。
  4: 操作系统要保护的区域，通常用于设备映射和系统结构。

  操作系统可以反复调用这个中断来获取完整的内存映射表，一直到没有更多的条目返回。

+ UEFI 内存映射：
  
  现代系统中，BIOS逐渐被UEFI（统一可扩展固件接口）取代，UEFI 提供了更灵活和强大的内存映射机制。操作系统启动时可以使用 UEFI 的 GetMemoryMap 函数直接从 UEFI 固件中读取内存布局。
  GetMemoryMap 返回的内存表结构比 BIOS 更加丰富，包含了不同内存区域的具体描述，包括页面大小、属性、内存区域类型等。UEFI 提供的内存区域类型非常细致，例如包含了代码段、数据段、ACPI 内存等。

  在 UEFI 下，内存类型分为多个类别，比如：
  EfiLoaderCode 和 EfiLoaderData: 加载器使用的代码和数据区。
  EfiBootServicesCode 和 EfiBootServicesData: 系统启动服务使用的代码和数据。
  EfiConventionalMemory: 可用于分配的常规内存。
  EfiACPIReclaimMemory 和 EfiACPIMemoryNVS: ACPI 的专用内存区域。
  通过 UEFI 内存表，操作系统可以更精确地了解哪些内存区域是可用的。

2. **读取多启动程序提供的内存信息**（如 GRUB）

在许多操作系统启动过程中，GRUB（GRand Unified Bootloader）等启动程序扮演了重要角色，特别是在 Linux 和一些开源操作系统中。GRUB 可以在内核加载之前获取系统的物理内存布局信息并传递给操作系统。这样，操作系统可以在不直接访问硬件的情况下轻松获取详细的内存布局。

**具体实现：**
+ 内存映射信息的获取和传递

GRUB 通常在启动过程中调用 BIOS 中断INT 0x15, AX=0xE820，并将获取的内存映射表存储在特定位置，内核可以通过读取该位置获取内存信息。
GRUB 会将内存信息和启动参数一起传递给内核。内核可以在启动时解析这些参数，使用 GRUB 提供的内存映射表，获取系统的物理内存布局。

+ 在 Linux 中读取 GRUB 提供的内存映射表：

在 Linux 系统中，GRUB 使用 Multiboot 标准加载内核，Multiboot 提供了获取内存映射的标准结构。Linux 内核启动后会读取该结构中的信息，并将其作为内核的内存分配参考。
GRUB 提供的内存信息与 BIOS 返回的信息类似，包括内存区域的起始地址、长度和类型（如可用内存、ACPI 保留内存等），这些信息被 Linux 内核的物理内存管理子系统用于后续的内存分配。

## lab2答辩部分问题解答

+ `memlayout.h`文件中,Page结构体中的表示空闲块数量的是哪个变量：
   + property
  
+ `default_pmm.c`文件中，传入的参数n是什么含义：
   + 参数n是空闲页面大小，其大小为4KiB

+ `pmm.h`文件中，函数page2pa有什么功能，是怎么使用的：
   + 功能：计算虚拟地址对应的物理地址
   + 使用：内部调用page2ppn函数，返回值为：page - pages + nbase



